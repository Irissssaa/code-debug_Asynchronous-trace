## 基于GDB的Rust异步函数调试方法

### 队伍信息

- 学校院系：北京工商大学计算机系；
- 队员：曾小红，张弈帆，董嘉誉；
- 指导老师：吴竞邦；
- 队伍ID：T202510011995491；
- 队伍名：Async_Avengers；
- 赛题：proj158 支持Rust语言的源代码级内核调试工具；

### 项目描述

本项目基于赛题 Proj-158：支持 Rust 语言的源代码级内核调试工具，在已有工作对 Rust 中同步函数调试方法的基础上，本项目面向 Rust 异步函数的调试，解决传统调试工具在 Rust 异步函数调试中断点后异步函数调用栈不正确，以及已有调试工具对不同运行时的 Rust 异步函数调试的通用性问题，设计并实现了一套面向 Rust 语言异步函数的基于 GDB 非侵入式代码插桩的动态调试工具。本项目主要采用基于编译产物静态分析得到异步函数状态机依赖关系并基于 GDB 动态“非侵入式”插桩目标函数，实现断点调试中区分异步函数执行流的函数调用栈打印，以及异步函数调用数据的跟踪和火焰图展示两个核心功能。

具体解决了以下五个关键问题：
1. Rust 异步函数的运行状态不透明：Rust 采用的 DWARF 调试信息格式本身是为同步
函数打造的，不能很好的适配 Rust 异步函数信息记录，导致异步函数内信息含义缺
失，运行状态不透明。可以通过实现相应的解析逻辑在 DWARF 信息中的特殊字段挖
掘出调试器所需要的信息，例如运行状态、局部变量等。
2. 传统调试器无法区分异步程序的逻辑执行流：传统调试器依靠物理调用栈回溯函数的
调用逻辑，Rust 异步函数的调用是非线性的、非阻塞的，物理调用栈会丢失异步函数
的逻辑调用关系，导致传统调试器无法区分异步程序的逻辑执行流。通过静态分析编
译产物获取异步函数依赖关系，区分程序执行流，对相关函数进行跟踪记录，动态构
建逻辑调用关系。
3. Rust 异步运行时缺少统一暴露接口：Rust 没有官方运行时，社区提供的各大运行时都
有自己的任务调度器，缺乏统一的状态暴露接口。可以通过静态解析编译产物，脱离
对运行时暴露上下文信息的依赖，即可解决这一问题。
4. 现有异步调试工具与运行时的强耦合导致通用性低：现有的 Rust 异步调试方案大多
与特定的平台或运行时深度绑定，通用性低。解决方法同上。
5. 缺乏灵活、低开销的按需追踪能力：全面的动态插桩会带来不可忽视的性能开销，缺
乏灵活性。我们基于 GDB 解析获取程序中完整的 poll 函数名单，采用“白名单式”追
踪，用户可自行设定跟踪目标。

根据问题分析，项目抽离出了以下四个目标：
- 目标 1：实现异步代码的静态依赖关系解析；
- 目标 2：实现“白名单”式按需追踪；
- 目标 3：实现基于 GDB 非侵入式动态插桩与模块化数据采集框架；
- 目标 4：实现多维度的异步行为可视化分析；
通过实现以上目标，能够解决当前 Rust 异步程序动态跟踪工具的普遍性问题。

### 参赛文档
我们的参赛项目决赛文档在[这里](https://gitlab.eduxiji.net/T202510011995491/project2721707-300492/-/blob/master/docs/Proj158_%E6%94%AF%E6%8C%81Rust%E8%AF%AD%E8%A8%80%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BA%A7%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%86%B3%E8%B5%9B%E6%96%87%E6%A1%A3.pdf)，请老师下载pdf格式文档阅读项目详细说明。

### 工作日志

我们团队的工作日志在[这里](https://github.com/Irissssaa/code-debug_Asynchronous-trace/discussions)

Note：由于美观、便捷等原因，我们的日志维护在远仓库的discussion板块，而非文件，不方便搬运。所以此处我们的工作日志外链到了github中。

### 项目进度

| 目标 | 完成情况 | 说明                                                         |
| :--: | :------: | :----------------------------------------------------------- |
|  1   |   完成   | ✓ objdump 输出信息解析<br />✓ 用 GDB 代替 objdump<br /> ✓ 构建异步函数依赖关系树<br /> |
|  2   | 完成 | ✓ 解析获取源代码中的完整 poll函数 |
|  3   |  完成  | ✓ 实现 GDB Python 脚本插件加载机制<br />✓ 实现自动在函数进入和返回处打断点的插件<br />✓ 实现在断点触发后自动收集异步函数运行状态的插件<br />✓ 实现从异步函数名对应到 poll 函数的插件 <br /> ✓实现异步程序跟踪框架（方便的异步运行时插桩，方便的异步运行时状态获取功能）<br />✓ 实现tracer（函数参数、全局/本地变量，栈回溯获取等）<br /> ✓ 内核态适配（拟embassy）<br /> ✓ 用户态适配（tokio） |
|  4   |   完成   | ✓ 利用 GDB 插桩功能生成和绘制火焰图相关的事件<br />✓ Chrome Trace Event 格式 json 输出 |

### 本仓库结构

```
├── docs/                     # 存放项目相关说明文档，包括参赛文档、实现思路、使用方法等
├── dwarf_analyzer/           # 初版DWARF 调试信息解析模块
├── gdb_profiler/             # 性能分析工具
├── results/                  # 存放分析工具生成的中间文件和最终结果，如 .json, .dot, .svg 文件
├── src/                      # 项目核心源代码目录
│   ├── core/                 # 存放与具体调试目标无关的核心、通用逻辑
│   │   ├── dwarf/            # DWARF 调试信息解析模块
│   │   ├── runtime_plugins/  # 存放具体的运行时插件，用于组合和配置 Tracers
│   │   ├── tracers/          # 存放具体的追踪探针，每个 Tracer 负责一种特定的数据采集任务
│   │   ├── __init__.py       # GDB 动态插桩框架的核心实现，包含断点、插件加载等逻辑
│   │   ├── config.py         # 项目配置文件，如指定当前要加载的运行时插件
│   │   ├── find_poll_fn.py   # 实现 find-poll-fn GDB 命令，用于查找所有 poll 函数
│   │   └── init_dwarf_analysis.py # 实现 init-dwarf-analysis GDB 命令，用于初始化 DWARF 解析树
│   ├── tokio/                  # 存放与 Tokio 运行时相关的特定分析逻辑或插件
│   ├── main.py                 # GDB 脚本的总入口，负责导入所有模块和命令
│   └── requirements.txt        # 项目的 Python 依赖库列表
├── tests/                    # 存放用于测试本工具功能的 Rust 测试项目
└── README.md                 # 项目的顶层说明文档

```
